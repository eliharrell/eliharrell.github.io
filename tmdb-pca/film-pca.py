# -*- coding: utf-8 -*-
"""screening-clustering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ymcMUvIpJce0ImG-s2KrJeV5G5244jZx
"""

import numpy as np
import pandas as pd

csad = pd.read_csv('/content/drive/MyDrive/Attendance Analytics/spr24-with-tmbd-data.csv')

csad

#select a quarter to cluster

qtr = 'spring'
yr  = 2024

sel0 = csad[(csad['year'] == yr) & (csad['quarter'] == qtr)]
sel = sel0.drop(['quarter', 'year', 'program', 'day', 'date', 'time', 'week',
       'tickets-sold', 'passes-used', 'attendance', 'format', 'hour', 'month',
       'month-day', 'full-date', 'num-genres'], axis = 1)

# do PCA

from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt

forpca = pd.get_dummies(sel, columns=['region', 'language']).dropna()
forpca.set_index('title', inplace=True)

scaler = StandardScaler()
forpca_scaled = scaler.fit_transform(forpca)

pca = PCA(n_components = 2)
pcs = pca.fit_transform(forpca_scaled)

forpca = forpca.reset_index()

# Create a DataFrame with the principal components
pc_df = pd.DataFrame(data=pcs, columns=['PC1', 'PC2'])

titled_pcdf = pd.concat([pc_df, forpca[['title']]], axis='columns')
with_days = pd.concat([titled_pcdf, sel0.reset_index()[['day']]], axis='columns')

# Visualize the data with labeled points
plt.figure(figsize=(200, 200))
scatter = plt.scatter(titled_pcdf['PC1'], titled_pcdf['PC2'], alpha=1)

# Label the points with film titles

for row in titled_pcdf.itertuples():
    # Split the title into square units (adjust the split logic as needed)
    title_lines = row.title.split()
    lines = []
    current_line = ""
    max_line_length = 10  # Adjust as needed

    for word in title_lines:
        if len(current_line) + len(word) <= max_line_length:
            current_line += word + " "
        else:
            lines.append(current_line.rstrip())
            current_line = word + " "
    lines.append(current_line.rstrip())

    # Calculate the total height of the text block (adjust spacing if needed)
    total_height = len(lines) * 10  # Assuming each line has a height of 10

    # Annotate using a circular shape
    plt.annotate('\n'.join(lines),
                 (row.PC1, row.PC2),
                 textcoords="offset points",
                 xytext=(0, 5),
                 ha='center')

plt.axis('off')

plt.show()

with_days

# finding the shortest path for a given series

def dist(pt1, pt2):
    x1 = pt1[0]
    y1 = pt1[1]
    x2 = pt2[0]
    y2 = pt2[1]
    return np.sqrt(((x1 - x2)**2) + ((y1-y2)**2))

def get_pt(series, idx):
    row = series.iloc[idx]
    return (row['PC1'], row['PC2'])

# returns index
def get_nearest(series, start_idx):
    start_pt = get_pt(series, start_idx)
    dists = dict()
    for i in range(len(series)):
        curr_pt = get_pt(series, i)
        dists[i] = dist(start_pt, curr_pt)
    ranked = dict(sorted(dists.items(), key=lambda x:x[1]))
    return list(ranked.items())[1][0]

def make_graph(series):
    graph = []
    for i in range(len(series)):
        pti = get_pt(series, i)
        dists = []
        for j in range(len(series)):
            ptj = get_pt(series, j)
            dists.append(dist(pti, ptj))
        graph.append(dists)
    return graph

from itertools import permutations

def get_min_path(graph, start):
    # store all vertex apart from source vertex
    vertex = []
    for i in range(len(graph)):
        if i != start:
            vertex.append(i)

    # store minimum weight Hamiltonian Cycle
    min_path = 100
    min_sequence = None
    next_permutation=permutations(vertex)
    for i in next_permutation:

        # store current Path weight(cost)
        current_pathweight = 0

        # compute current path weight
        k = start
        for j in i:
            current_pathweight += graph[k][j]
            k = j
        current_pathweight += graph[k][start]
        # update minimum
        if current_pathweight < min_path:
            min_path = current_pathweight
            min_sequence = (start,) + i + (start,)

    return list(min_sequence)[:len(min_sequence)-1]

def draw_min_path(series, color):
    serpts = with_days[with_days['day'] == series]
    serpts = serpts.reset_index()
    mp = get_min_path(make_graph(serpts), 0)

    for i in range(len(mp)):
        a = serpts.iloc[mp[i]]
        if i == len(mp) - 1:
            b = serpts.iloc[mp[0]]
        else:
            b = serpts.iloc[mp[i+1]]
        xs = [a['PC1'], b['PC1']]
        ys = [a['PC2'], b['PC2']]
        plt.plot(xs, ys, '-', markersize=0, color=color, linewidth=0.25)
        plt.scatter(serpts['PC1'], serpts['PC2'], color=color, s=0.25, zorder=10+i, label=serpts['title'])  # scatter points on top

        for idx, row in serpts.iterrows():
            plt.annotate(row['title'], (row['PC1'], row['PC2']),
                        textcoords="offset points",
                        xytext=(-2, 1),
                        ha='right',
                        fontsize=1,
                        rotation=-45,
                        rotation_mode='anchor',
                        zorder = 100,
                        color = color)


    plt.xlim([min(with_days['PC1'] - 0.5), max(with_days['PC1']) + 0.5])
    plt.ylim([min(with_days['PC2'] - 0.5), max(with_days['PC2']) + 0.5])

allsers = ['mon', 'tue',  'wed',   'thu1',   'fri',    'sun1', 'sun2',  'sat3', 'se']
colors = ['red',  'green', 'blue', 'orange', 'purple', 'cyan', 'black', 'gray', 'brown']


plt.figure(figsize=(20, 20))
plt.axis('off')

for i in range(9):
    draw_min_path(allsers[i], colors[i])

thu2 = with_days[with_days['day'] == 'thu2']
plt.scatter(thu2['PC1'], thu2['PC2'], color='magenta', s=0.25, zorder=15, label=thu2['title'])
for idx, row in thu2.iterrows():
    plt.annotate(row['title'], (row['PC1'], row['PC2']),
                 textcoords="offset points",
                 xytext=(-2, 1),
                 ha='right',
                 fontsize=1,
                 rotation=-45,
                 rotation_mode='anchor',
                 zorder=100,
                 color = 'magenta')

plt.savefig('output_plot.pdf', format='pdf')

plt.show()